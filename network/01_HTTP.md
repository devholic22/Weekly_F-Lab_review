## HTTP
참고 자료 - 최범균의 JSP 2.3 웹 프로그래밍, 김영한 모든 개발자를 위한 HTTP 웹 기본 지식, MDN 문서
* HyperText Transfer Protocol
* 웹 브라우저와 웹 서버가 HTML을 비롯한 이미지, 동영상, 문서 등 다양한 데이터를 주고받을 때 사용하는 규칙
### 규칙
* 요청 규칙: 웹 브라우저가 웹 서버에 HTML과 같은 것을 요청할 때 사용할 데이터 구성 규칙
* 응답 규칙: 웹 서버가 웹 브라우저에 HTML과 같은 것을 전송할 때 사용할 데이터 구성 규칙
### 구성
* 요청
  * 요청 줄: HTTP 요청 방식과 요청하는 자원의 경로를 지정
  * 헤더: 서버가 응답을 생성하는 데 참조할 수 있는 정보를 전송 (브라우저 정보 등), 필요 시 임의의 헤더 추가 가능
  * 몸체: 정보 전송 (파일 업로드 등)
* 응답
  * 응답 줄: 요청에 대한 응답 코드를 전송 (200 OK 등)
  * 헤더: 응답에 대한 정보 전송, 응답의 몸체가 어떤 데이터인지, 길이는 어떻게 되는지 등에 대한 정보를 담음
  * 몸체: 웹 브라우저가 요청한 자원의 내용을 담음. HTML 문서나 이미지 파일 데이터 등이 몸체 영역을 이용해서 전달
### 버전
* HTTP 1.1: 가장 많이 사용 (1997)
* HTTP 2: 성능 개선 (2015)
* HTTP 3: 진행 중 (TCP 대신 UDP 사용 등)
### 특징
* 무상태 (Stateless)
  * 서버가 클라이언트의 상태를 보존하지 않음
  * 서버 확장성 증가
  * 클라이언트가 추가 데이터를 전송해야 함
  * 예시로는 어느 종업원이든 고객의 요청을 처리할 수 있다. 그리고 고객의 정보를 기억하지 않는다.
  * 세션 등의 경우에서는 상태 유지 (Stateful)를 한다.
* 비연결성 (Connectionless)
  * HTTP는 기본이 연결을 유지하지 않는 모델, 일반적으로 초 단위 이하의 빠른 속도로 응답
  * 서버 자원 효율적 사용 가능
  * TCP/IP 연결을 새로 맺어야 함 - 시간 증가
  * HTTP 지속 연결 (Persistent Connections)로 문제 해결
  * HTTP/2, HTTP/3에서 더 많은 최적화 진행
  * 클라이언트가 서버에 요청을 하고 응답을 받으면 바로 TCP/IP 연결을 끊어 연결을 유지하지 않도록 함으로써 서버의 자원을 효율적으로 관리하고 수많은 클라이언트의 요청에 대응할 수 있도록 함
### HTTP 메서드
#### GET
* 리소스 조회
* 멱등성, 캐시 가능
* 서버에 전달하고 싶은 데이터는 쿼리를 통해서 전달
* 메시지 바디를 이용해서 데이터를 전달할 수는 있으나 지원하지 않는 곳이 많아 권장하지 않음
  * 캐시 시 바디를 참조하지 않음
#### HEAD
* 특정 리소스를 GET 메서드로 요청했을 때 돌아올 헤더를 요청
* 응답은 메시지 바디를 가지지 못함 (존재하더라도 무시)
* 멱등성, 캐시 가능
#### POST
* 요청 데이터 처리
* 메시지 바디를 통해 서버로 요청 데이터 전달
* 서버는 요청 데이터를 처리
  * 메시지 바디를 통해 들어온 데이터를 처리하는 모든 기능 수행
* 주로 전달된 데이터로 신규 리소스 등록, 프로세스 처리에 사용
* Location으로 생성된 리소스의 위치를 알려줄 수 있음
  * 201 Created + Location 조합
* 단순히 데이터를 생성하거나 변경하는 것을 넘어 특정 프로세스를 처리해야 하는 경우 유용
  * 주문에서 결제 완료 - 배달 시작 - 배달 완료
* POST를 사용하면 캐시를 사용하기 어려움
  * POST는 보통 새로운 데이터를 제출하는 경우 사용하며, 서버의 상태를 변경하기 때문에 캐시하지 않음 (+ 비멱등성)
  * 대부분의 서버는 POST 응답에 Cache-Control 헤더를 포함하지 않거나 no-store와 같이 캐시를 금지함
  * 메시지 바디를 캐시 키로 고려하기에는 구현이 쉽지 않음
#### PUT
* 리소스를 완전히 대체하는 데 중점
* 리소스가 있으면 대체, 없으면 생성 (덮어버림)
* 멱등성 but 캐시 불가능
  * 리소스를 완전히 대체하자는 취지
* 클라이언트가 리소스를 식별한 경우에 해당
  * 클라이언트가 리소스 위치를 알고 URI를 지정
  * POST와의 차이점
#### PATCH
* 리소스를 부분 변경하는 데 중점
* HTTP에서 PATCH를 받아들이지 못하는 경우에는 개념상으로는 POST를 이용
* 비멱등성, 캐시 불가능 (PUT과 같은 방식으로 사용하여 멱등하게 할 수는 있음)
  * 일부분을 변경하는 데 중점이기 때문
#### DELETE
* 리소스 제거 용도
* 멱등성 but 캐시 불가능
#### OPTIONS
* 주어진 URL 또는 서버에 대해 허용된 통신 옵션을 요청
* 멱등성 but 캐시 불가능
* CORS 과정에서 발생 가능 (Preflight request)
#### TRACE
* 클라이언트가 요청을 보내면 서버는 요청을 그대로 다시 반환
* 주로 요청이 서버에 도달하기까지의 경로를 진단하는 데 사용
* 멱등성 but 캐시 불가능
#### CONNECT
* 서버와 클라이언트 간의 터널을 설정하여 주로 SSL (HTTPS) 연결을 위해 사용됨
* 비멱등성, 캐시 불가능
### HTTP 상태 코드
* 상태 코드: 클라이언트가 보낸 요청의 처리 상태를 응답에서 알려주는 기능
#### 1xx (Informational): 요청이 수신되어 처리중
* 101 (Switching Protocols): WebSocket 등에서 사용
* 103 (Early Hints): 페이지 로드 속도를 빠르게 하기 위해 사용
#### 2xx (Successful): 요청 정상 처리
* 200 (OK): 요청 성공
* 201 (Created): 주로 POST에 의해 리소스가 생성되었음을 의미, Location과 함께 사용
* 202 (Accepted): 요청이 접수되었으나 처리가 완료되지 않음. 배치 처리 같은 곳에서 사용
* 204 (No-Content): 서버가 요청을 성공적으로 수행했지만, 응답 페이로드 본문에 보낼 데이터가 없다
  (삭제 등)
#### 3xx (Redirection): 요청을 완료하려면 추가 행동 필요
* 300 (Multiple Choices)
  * 요청에 두 개 이상의 가능한 응답이 있음을 의미
  * 응답 중 하나를 선택하는 표준 방법이 없기 때문에 잘 사용되지 않음
  * 서버에 선호하는 선택 사항이 있을 경우 Location 헤더 생성 필요
* 301 (Moved Permanently)
  * 리다이렉트 요청 시 요청 메서드가 GET으로 변하고 본문이 제거될 수 있음 (MAY)
* 302 (Found)
  * 일시 리다이렉션에 해당
  * 리다이렉트 시 요청 메서드가 GET으로 변하고 본문이 제거될 수 있음 (MAY - 대부분)
  * 실무에서 많이 사용 중
* 303 (See Other)
  * 302와 기능 같음
  * 리다이렉트 시 요청 메서드가 GET으로 변경
* 304 (Not Modified)
  * 요청한 자원이 변경되지 않았으므로 클라이언트에서 캐시된 자원을 사용하도록 권하는 상태 코드
  * 응답에 메시지 바디 사용 X (로컬 캐시 이용)
  * 조건부 GET, HEAD 요청 시 사용
* 307 (Temporary Redirect)
  * 302와 기능 같음
  * 리다이렉트 시 요청 메서드와 본문 유지 (요청 메서드를 변경하면 안된다 - MUST NOT)
* 308 (Permanent Redirect)
  * 301과 기능 같음
  * 리다이렉트 시 요청 메서드와 본문 유지
  * 실무에서는 경로가 달라지면 보내야 할 데이터 또한 다 달라지는 경우가 있기 때문에 일시 리다이렉션을 더 많이 사용
* 어떤 것을 사용?
  * 302 Found: GET으로 변할 수 있음
  * 303 See Other: 메서드가 GET으로 변경
  * 307 Temporary Redirect: 메서드가 변하면 안됨
  * 303, 307을 권장하지만 많은 애플리케이션 라이브러리들이 302를 기본값으로 사용
  * 자동 리다이렉션 시 GET으로 변해도 되면 302를 사용해도 큰 문제 X
#### 4xx (Client Error): 클라이언트 오류, 잘못된 문법 등으로 서버가 요청을 수행할 수 없음
* 400 (Bad Request): 클라이언트가 잘못된 요청을 해서 서버가 요청을 처리할 수 없음. 요청 구문, 메시지 등 오류.. API 스펙이 맞지 않을 경우 (클라이언트는 요청 내용을 다시 검토해야 함)
* 401 (Unauthorized): 클라이언트가 해당 리소스에 대한 인증 (Authentication)이 필요함. 오류 발생 시 WWW-Authenticate 헤더와 함께 인증 방법을 설명
* 403 (Forbidden): 서버가 요청을 이해했지만 승인을 거부. 주로 인증 자격 증명은 있지만 접근 권한이 불충분 (진정한 Unauthorized)
* 404 (Not Found): 요청 리소스를 서버에서 찾을 수 없음. 또는 클라이언트가 권한이 부족한 리소스에 접근할 때, 해당 리소스를 숨기고 싶을 때 이용
#### 5xx (Server Error): 서버 오류, 서버가 정상 요청을 처리하지 못함
* 500 (Internal Server Error): 서버 오류. 서버 문제로 오류 발생, 서버에 문제가 있기 때문에 재시도 하면 성공할 수도 있다. 진짜 서버에 문제가 있을 때 발생시켜야 한다.
* 503 (Service Unavaailable): 서비스 이용 불가. 서버가 일시적인 과부하 또는 예정된 작업으로 잠시 요청을 처리할 수 없음. Retry-After 헤더 필드로 얼마 뒤에 복구되는지 보낼 수도 있음 (but 대부분 예측 불가능)
### HTTPS와의 차이점
[참고 링크](https://kanoos-stu.tistory.com/46)
* HTTPS는 HTTP에 암호화 및 인증을 적용한 것
* TLS(SSL은 TLS의 전신 - 차이 거의 없음)를 적용하여 전달되는 모든 데이터를 암호화하고 특정 유형의 사이버 공격도 차단
  * 웹에서 전송되는 데이터를 암호화 - 데이터를 가로채려 해도 복호화 거의 불가능
  * 클라이언트-서버 간 handshake를 통해 인증이 이루어짐 (RSA 알고리즘 이용)
  * 데이터 무결성을 위해 데이터에 디지털 서명을 하여 데이터가 의도적으로 도착하기 전 조작 여부를 확인
